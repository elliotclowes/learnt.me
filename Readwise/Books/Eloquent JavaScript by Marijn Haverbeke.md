![rw-book-cover](https://readwise-assets.s3.amazonaws.com/media/reader/parsed_document_assets/44808704/cover-image-9781593279516_EnIZY65.jpg)

## Metadata
- Author: [[Marijn Haverbeke]]
- Full Title: Eloquent JavaScript
- Category: #books
- Summary: Completely revised and updated, this best-selling introduction to programming in JavaScript focuses on writing real applications.Eloquent JavaScript dives into the JavaScript language to show programmers how to write elegant, effective JavaScript code. Like any good programming book, Eloquent JavaScript begins with fundamentals—variables, control structures, functions, and data structures—then moves on to complex topics like object-oriented programming and regular expressions. This third edition introduces new features covering the 2017 version of JavaScript, such as class notation, arrow functions, iterators, async functions, template strings, and black scope. Author Marijn Haverbeke keeps the friendly tone and easy-to-follow explanations that made the original a hit, and he adds new exercises for readers to test their skills. Eloquent JavaScript will have readers fluent in the language of the web in no time, eloquently.

## Highlights
***

> It is up to you to make the necessary effort. When you are struggling to follow the book, do not jump to any conclusions about your own capabilities. You are fine—you just need to keep at it. Take a break, reread some material, and make sure you read and understand the example programs and exercises. Learning is hard work, but everything you learn is yours and will make subsequent learning easier. ([View Highlight](https://read.readwise.io/read/01gx79xpg8y70sc0435g2be6ha))

***

> It is important to note that JavaScript has almost nothing to do with the programming language named Java. The similar name was inspired by marketing considerations rather than good judgment. When JavaScript was being introduced, the Java language was being heavily marketed and was gaining popularity. Someone thought it was a good idea to try to ride along on this success. Now we are stuck with the name. ([View Highlight](https://read.readwise.io/read/01gx7abv9htztkx60kpgef8xty))

***

> After its adoption outside of Netscape, a standard document was written to describe the way the JavaScript language should work so that the various pieces of software that claimed to support JavaScript were actually talking about the same language. This is called the ECMAScript standard, after the Ecma International organization that did the standardization. In practice, the terms ECMAScript and JavaScript can be used interchangeably—they are two names for the same language. ([View Highlight](https://read.readwise.io/read/01gx7acz1tyb1xsn9hks3mxsft))

***

> There are those who will say *terrible* things about JavaScript. Many of these things are true. When I was required to write something in JavaScript for the first time, I quickly came to despise it. It would accept almost anything I typed but interpret it in a way that was completely different from what I meant. This had a lot to do with the fact that I did not have a clue what I was doing, of course, but there is a real issue here: JavaScript is ridiculously liberal in what it allows. The idea behind this design was that it would make programming in JavaScript easier for beginners. In actuality, it mostly makes finding problems in your programs harder because the system will not point them out to you ([View Highlight](https://read.readwise.io/read/01gx7adgcfrms94rnt1chz0bz0))

***

> Web browsers are not the only platforms on which JavaScript is used. Some databases, such as MongoDB and CouchDB, use JavaScript as their scripting and query language. ([View Highlight](https://read.readwise.io/read/01gx7afbcevbwyb17jh4qmwt5n))

***

> The easiest way to run the example code in the book, and to experiment with it, is to look it up in the online version of the book at *[https://eloquentjavascript.net](https://eloquentjavascript.net)*. There, you can click any code example to edit and run it and to see the output it produces. To work on the exercises, go to *[https://eloquentjavascript.net/code](https://eloquentjavascript.net/code)*, which provides starting code for each coding exercise and allows you to look at the solutions. ([View Highlight](https://read.readwise.io/read/01gx7ah8fb6x49keepj33dax3g))

***

> To be able to work with such quantities of bits without getting lost, we must separate them into chunks that represent pieces of information. In a JavaScript environment, those chunks are called *values*. Though all values are made of bits, they play different roles. Every value has a type that determines its role. Some values are numbers, some values are pieces of text, some values are functions, and so on.
>
> To create a value, you must merely invoke its name. This is convenient. You don’t have to gather building material for your values or pay for them. You just call for one, and *whoosh*, you have it. ([View Highlight](https://read.readwise.io/read/01gx7aqtxkkc7qfxjc1pepr5ar))

Tags: [[javascript]] [[programming]] 

***

> Calculations with whole numbers (also called *integers*) smaller than the aforementioned 9 quadrillion are guaranteed to always be precise. Unfortunately, calculations with fractional numbers are generally not. Just as *π* (pi) cannot be precisely expressed by a finite number of decimal digits, many numbers lose some precision when only 64 bits are available to store them. This is a shame, but it causes practical problems only in specific situations. The important thing is to be aware of it and treat fractional digital numbers as approximations, not as precise values. ([View Highlight](https://read.readwise.io/read/01gx7avnyfdn89mxzwfc9b7dqc))

***

> Here is what they look like in JavaScript:
>
> 100 + 4 * 11
>
> The + and * symbols are called *operators*. The first stands for addition, and the second stands for multiplication. Putting an operator between two values will apply it to those values and produce a new value.
>
> But does the example mean “add 4 and 100, and multiply the result by 11,” or is the multiplication done before the adding? As you might have guessed, the multiplication happens first. But as in mathematics, you can change this by wrapping the addition in parentheses.
>
> (100 + 4) * 11 ([View Highlight](https://read.readwise.io/read/01gx7axs25753tnswrqmec7p31))

***

> When operators appear together without parentheses, the order in which they are applied is determined by the *precedence* of the operators. The example shows that multiplication comes before addition. The / operator has the same precedence as *. Likewise for + and -. When multiple operators with the same precedence appear next to each other, as in 1 - 2 + 1, they are applied left to right: (1 - 2) + 1.
>
> These rules of precedence are not something you should worry about. When in doubt, just add parentheses.
>
> There is one more arithmetic operator, which you might not immediately recognize. The % symbol is used to represent the *remainder* operation. X % Y is the remainder of dividing X by Y. For example, 314 % 100 produces 14, and 144 % 12 gives 0. The remainder operator’s precedence is the same as that of multiplication and division. You’ll also often see this operator referred to as *modulo*. ([View Highlight](https://read.readwise.io/read/01gx7b36h4h2zjp70ne3h6arbc))

***

> NaN stands for “not a number,” even though it *is* a value of the number type. You’ll get this result when you, for example, try to calculate 0 / 0 (zero divided by zero), Infinity - Infinity, or any number of other numeric operations that don’t yield a meaningful result. ([View Highlight](https://read.readwise.io/read/01gx7b4m87h6j3yavavq2p6x2m))

***

> *Newlines* (the characters you get when you press ENTER) can be included without escaping only when the string is quoted with backticks (`). ([View Highlight](https://read.readwise.io/read/01gx7b5nkqz4rgs76y44d0cfv2))

***

> To make it possible to include such characters in a string, the following notation is used: whenever a backslash (\) is found inside quoted text, it indicates that the character after it has a special meaning. This is called *escaping* the character. A quote that is preceded by a backslash will not end the string but be part of it. When an n character occurs after a backslash, it is interpreted as a newline. Similarly, a t after a backslash means a tab character. Take the following string:
>
> "This is the first line\nAnd this is the second"
>
> The actual text contained is this:
>
> This is the first line 
>
> And this is the second
>
> There are, of course, situations where you want a backslash in a string to be just a backslash, not a special code. If two backslashes follow each other, they will collapse together, and only one will be left in the resulting string value. This is how the string "A newline character is written like "\n"." can be expressed:
>
> "A newline character is written like \"\\n\"." ([View Highlight](https://read.readwise.io/read/01gx7b923zft7rb1b159devr2x))

***

> Strings cannot be divided, multiplied, or subtracted, but the + operator *can* be used on them. It does not add, but it *concatenates*—it glues two strings together. The following line will produce the string "concatenate":
>
> "con" + "cat" + "e" + "nate" ([View Highlight](https://read.readwise.io/read/01gx7bcc73224qv7ry98s8yn23))

***

> Backtick-quoted strings, usually called *template literals*, can do a few more tricks. Apart from being able to span lines, they can also embed other values.
>
> `half of 100 is ${100 / 2}`
>
> When you write something inside ${} in a template literal, its result will be computed, converted to a string, and included at that position. The example produces half of 100 is 50. ([View Highlight](https://read.readwise.io/read/01gx7bfchdmv1zrwcy8e640jmm))

***

> Not all operators are symbols. Some are written as words. One example is the typeof operator, which produces a string value naming the type of the value you give it.
>
> console.log(typeof 4.5) 
>
> // → number 
>
> console.log(typeof "x") 
>
> // → string ([View Highlight](https://read.readwise.io/read/01gx7bgdv4c1a72ezxc6414yve))

Tags: [[javascript]] [[programming]] 

***

> The other operators shown all operated on two values, but typeof takes only one. Operators that use two values are called *binary* operators, while those that take one are called *unary* operators. The minus operator can be used both as a binary operator and as a unary operator. ([View Highlight](https://read.readwise.io/read/01gx7bh5xwejjv2qzvwhxa6ty2))

***

> The > and < signs are the traditional symbols for “is greater than” and “is less than,” respectively. They are binary operators. Applying them results in a Boolean value that indicates whether they hold true in this case.
>
> Strings can be compared in the same way.
>
> console.log("Aardvark" < "Zoroaster") 
>
> // → true ([View Highlight](https://read.readwise.io/read/01gx7bkedyjtwp8d3thr44v9sh))

***

> The way strings are ordered is roughly alphabetic but not really what you’d expect to see in a dictionary: uppercase letters are always “less” than lowercase ones, so "Z" < "a", and nonalphabetic characters (!, -, and so on) are also included in the ordering. When comparing strings, JavaScript goes over the characters from left to right, comparing the Unicode codes one by one. ([View Highlight](https://read.readwise.io/read/01gx7bkq968687ak4prf9kytw3))

***

> There is only one value in JavaScript that is not equal to itself, and that is NaN (“not a number”).
>
> console.log(NaN == NaN) 
>
> // → false
>
> NaN is supposed to denote the result of a nonsensical computation, and as such, it isn’t equal to the result of any *other* nonsensical computations. ([View Highlight](https://read.readwise.io/read/01gx7bmywkdftkvyv59ea25mat))

***

> The && operator represents logical *and*. It is a binary operator, and its result is true only if both the values given to it are true.
>
> console.log(true && false) 
>
> // → false 
>
> console.log(true && true) 
>
> // → true ([View Highlight](https://read.readwise.io/read/01gx7bpvnn9ys21p73yecrhhjq))

***

> The || operator denotes logical *or*. It produces true if either of the values given to it is true.
>
> console.log(false || true) 
>
> // → true 
>
> console.log(false || false) 
>
> // → false ([View Highlight](https://read.readwise.io/read/01gx7bq38cg91dzbvp77yhtn7p))

***

> *Not* is written as an exclamation mark (!). It is a unary operator that flips the value given to it—!true produces false, and !false gives true. ([View Highlight](https://read.readwise.io/read/01gx7bs2wr3j9qzyafx7wbxt5x))

